<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Type safety and Spark Datasets in Scala</title>
    <meta name="description" content="An example by which we demonstrate how we can add constraints to business domain for compile time validation of business logic!">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/prism.base16.monokai.dark.css">
    
      <link rel="stylesheet" href="/css/home.css">
    
      <link rel="stylesheet" href="/css/footer.css">
    
      <link rel="stylesheet" href="/css/post.css">
    
    <link rel="alternate" href="." type="application/atom+xml" title="">
    <link rel="alternate" href="." type="application/json" title="">
    <script src="https://kit.fontawesome.com/0a5d5a6a83.js" crossorigin="anonymous"></script>
  </head>
  <body>
  <section class="container-fluid align-items-center">
       <div class="row dark-bg">
         <nav class="navbar navbar-expand-lg">
    <span class="navbar-brand">
        <img class="hero" src="/images/about_me.jpg" />
    </span>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNavDropdown">
      <ul class="navbar-nav">
      
        <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
        <li class="nav-item"><a class="nav-link" href="/tech/">Tech</a></li>
      </ul>
    </div>
  </nav>
      </div>
      <div class="row main-row">
      <div class="col-lg-12">
       
<section class="container-fluid align-items-center post" >
  <img src="https://source.unsplash.com/WeA1uHnzf60/1600x900" class="banner"/>
  <div class="credit">
    <a target="_blank" href="https://unsplash.com/@tuannguyenminh">Tuân Nguyễn Minh</a> on 
    <a target="_blank" href="https://unsplash.com">Unsplash </a>
  </div>
  <h1>Type safety and Spark Datasets in Scala
  </h1>

  <div class="meta">
  <p class="date">Jan 01, 2019</p>
    
        <a href="/tags/tech/" class="post-tag">#tech</a>
        <a href="/tags/scala/" class="post-tag">#scala</a>
        <a href="/tags/data-engineering/" class="post-tag">#data-engineering</a>
    
  </div>
  <p>
    <p>Working with Spark Datasets have been quite interesting and most of the time rewarding in our current project. It has a simple yet powerful API that abstracts out the need to code in complex transformations and computations. To be honest, we also have a fairly straightforward use case: few domain entities, fewer transformations based on simple joins.</p>
<p>However, there are also few things that have been counterproductive to us but I am going to focus on one of them: lack of type safety in some operations, particularly, joins.</p>
<pre class="language-scala"><code class="language-scala">dataSetA<span class="token punctuation">.</span>join<span class="token punctuation">(</span>dataSetB<span class="token punctuation">,</span> <span class="token string">"columnA"</span><span class="token punctuation">)</span></code></pre>
<p>The above code will fail on runtime if either of dataSetA and dataSetB (or both) don’t have “columnA” column. This is a waste of resources at multiple levels: from precious CPU cycles to developer’s time. In the remainder of this blog, we will add compile-time safety to join operations and learn a lot in the process.</p>
<blockquote>
<p><strong>Before we proceed</strong>, a disclaimer: This is not an unsolved problem. <a href="https://github.com/typelevel/frameless">Frameless</a> does a fantastic job at providing the type-safety for Datasets. However, it is a very evolved and complete framework which provides a newer abstraction of TypedDatasets and we really did not want to add an external dependency when we just wanted to have type safety in our select Dataset methods. The solution we are going to formulate is what Frameless does which inturn leverages on generic programming using awesome <a href="https://github.com/milessabin/shapeless">Shapeless</a>.</p>
</blockquote>
<hr>
<h4 id="problem-statement">Problem Statement <a class="direct-link" href="#problem-statement">#</a></h4>
<p>Let’s come up with goals we want to achieve at the end of this post:</p>
<ol>
<li>When we access a column by name, the compilation should fail if the column does not exist in the dataset.</li>
<li>When we join two datasets, the compilation should fail if the joining column is not part of either one of the dataset or if present, not of the same type.</li>
<li>Some good DSL for doing above never hurts!</li>
</ol>
<hr>
<h4 id="step-0%3A-basics">Step 0: Basics <a class="direct-link" href="#step-0%3A-basics">#</a></h4>
<p>For any Dataset of type T (case class/Product type), we need to understand all the properties of type T along with their types. This means that we want to move from a <em>specialized</em> T to <em>generalized</em> list of properties with types. and this, in a very very simplified way of explanation, is what <em>Shapeless</em> provides. It provides a conversion to and from a <strong>case class</strong> and a <strong>heterogeneous list (HList)</strong> and a bouquet of functions to apply on the list. The best material to read about shapeless is <a href="https://books.underscore.io/shapeless-guide/shapeless-guide.html">this</a> and I strongly suggest to give it a thorough read.</p>
<p>For now, we can do with a knowledge that shapeless provides an interface LabelledGeneric which provides the interface.</p>
<p>This can be explained as below:</p>
<pre class="language-scala"><code class="language-scala"><br><span class="token keyword">case</span> <span class="token keyword">class</span> Person<span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> isEmployee<span class="token operator">:</span> <span class="token builtin">Boolean</span><span class="token punctuation">)</span><br><span class="token comment">//defined class Person</span><br><br>generic <span class="token operator">=</span> LabelledGeneric<span class="token punctuation">[</span>Person<span class="token punctuation">]</span><br><span class="token comment">//generic: shapeless.LabelledGeneric[Person]{type Repr = shapeless.::[String with shapeless.labelled.KeyTag[Symbol with shapeless.tag.Tagged[String("name")],String],shapeless.::[Int with shapeless.labelled.KeyTag[Symbol with shapeless.tag.Tagged[String("age")],Int],shapeless.::[Boolean with shapeless.labelled.KeyTag[Symbol with shapeless.tag.Tagged[String("isEmployee")],Boolean],shapeless.HNil]]]}</span><br><br><span class="token comment">//usage:</span><br><span class="token keyword">val</span> person <span class="token operator">=</span> Person<span class="token punctuation">(</span><span class="token string">"John Doe"</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><br><br><span class="token keyword">val</span> hlist <span class="token operator">=</span> generic<span class="token punctuation">.</span>to<span class="token punctuation">(</span>person<span class="token punctuation">)</span><br><span class="token comment">//hlist: generic.Repr = John Doe :: 32 :: true :: HNil</span><br><br>HNilgeneric<span class="token punctuation">.</span>from<span class="token punctuation">(</span>hlist<span class="token punctuation">)</span><br><span class="token comment">//res0: Person = Person(John Doe,32,true)</span><br></code></pre>
<hr>
<h4 id="step-1%3A-property-exists%3F">Step 1: Property Exists? <a class="direct-link" href="#step-1%3A-property-exists%3F">#</a></h4>
<blockquote>
<p><em>Given a type T, if there exists a property of name PName and type PType then yes, the conditions are satisfied</em></p>
</blockquote>
<pre class="language-scala"><code class="language-scala"><span class="token annotation punctuation">@implicitNotFound</span><span class="token punctuation">(</span>msg <span class="token operator">=</span> <span class="token string">"${PName} not found in ${T}"</span><span class="token punctuation">)</span><br><span class="token keyword">trait</span> PropertyExists<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PName<span class="token punctuation">,</span> PType<span class="token punctuation">]</span><br><br><span class="token keyword">object</span> PropertyExists <span class="token punctuation">{</span><br>  <span class="token keyword">def</span> apply<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PType<span class="token punctuation">]</span><span class="token punctuation">(</span>column<span class="token operator">:</span> Witness<span class="token punctuation">)</span><span class="token punctuation">(</span><br>      <span class="token keyword">implicit</span> exists<span class="token operator">:</span> PropertyExists<span class="token punctuation">[</span>T<span class="token punctuation">,</span> column<span class="token punctuation">.</span>T<span class="token punctuation">,</span> PType<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> PropertyExists<span class="token punctuation">[</span>T<span class="token punctuation">,</span> column<span class="token punctuation">.</span>T<span class="token punctuation">,</span> PType<span class="token punctuation">]</span> <span class="token operator">=</span><br>    exists<br><br>  <span class="token keyword">implicit</span> <span class="token keyword">def</span> implicitProvider<span class="token punctuation">[</span>T<span class="token punctuation">,</span> H <span class="token operator">&lt;</span><span class="token operator">:</span> HList<span class="token punctuation">,</span> PName<span class="token punctuation">,</span> PType<span class="token punctuation">]</span><span class="token punctuation">(</span><br>      <span class="token keyword">implicit</span><br>      gen<span class="token operator">:</span> LabelledGeneric<span class="token punctuation">.</span>Aux<span class="token punctuation">[</span>T<span class="token punctuation">,</span> H<span class="token punctuation">]</span><span class="token punctuation">,</span><br>      selector<span class="token operator">:</span> Selector<span class="token punctuation">.</span>Aux<span class="token punctuation">[</span>H<span class="token punctuation">,</span> PName<span class="token punctuation">,</span> PType<span class="token punctuation">]</span><br>  <span class="token punctuation">)</span><span class="token operator">:</span> PropertyExists<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PName<span class="token punctuation">,</span> PType<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> PropertyExists<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PName<span class="token punctuation">,</span> PType<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>Let’s break down the gist line by line:</p>
<ol>
<li>We define a trait PropertyExists for type T which also expects types PName ( for Property Name) and PType ( for Property Type), we don’t worry about the properties/methods of the trait as the existence of such instance is truthfulness of our condition.</li>
<li>We define an <code>apply</code> method which accepts a Witness and implicitly expects an instance of PropertyExists for a certain PType. Witness is one of the utility abstractions of Shapeless which given a Symbol returns handle to its type and value.</li>
<li>But how to do we pass the implicit parameter of PropertyExists? Also, where are we looking for the properties? well, the implicit is provided by implicitProvider which rely on LabelledGeneric that we introduced above. It takes a couple of more implicitly created parameters. Let’s dissect them:</li>
</ol>
<pre class="language-scala"><code class="language-scala"><span class="token keyword">implicit</span> gen<span class="token operator">:</span> LabelledGeneric<span class="token punctuation">.</span>Aux<span class="token punctuation">[</span>T<span class="token punctuation">,</span> H<span class="token punctuation">]</span></code></pre>
<p>gen provides the heterogenous list (HList) representation of type T. It uses the <a href="http://gigiigig.github.io/posts/2015/09/13/aux-pattern.html">Aux Pattern</a> (another must read for type-level programming!) to forward the result type to the next implicit parameter creation</p>
<pre class="language-scala"><code class="language-scala">selector<span class="token operator">:</span> Selector<span class="token punctuation">.</span>Aux<span class="token punctuation">[</span>H<span class="token punctuation">,</span> PName<span class="token punctuation">,</span> PType<span class="token punctuation">]</span></code></pre>
<p>The Selector is one of the simpler abstraction of Shapeless which provides the PType given it finds the propertyName PName in record H.</p>
<p>So in simpler terms, the implicitProvider talks the following:</p>
<blockquote>
<p>For a given <strong>type T</strong>, if you are able to create a <strong>HList</strong> of type <strong>H</strong> from <strong>LabelledGeneric[T]</strong> and then if you are able to also <strong>select PType</strong> from that HList <strong>H</strong> a property of name <strong>PName</strong>, then go ahead and provide a <strong>PropertyExists</strong> instance for type <strong>T</strong>, <strong>PName</strong> and <strong>PType</strong>.</p>
</blockquote>
<hr>
<h4 id="step-2%3A-first-test-of-type-safety">Step 2: First Test of Type Safety <a class="direct-link" href="#step-2%3A-first-test-of-type-safety">#</a></h4>
<p>Now that we have our PropertyExists, let's have our first stab at type safety: Creating a Column instance from a key and failing on compile time if it doesn’t exist.</p>
<pre class="language-scala"><code class="language-scala"><span class="token keyword">object</span> syntax <span class="token punctuation">{</span><br>  <span class="token keyword">implicit</span> <span class="token keyword">class</span> RichDataSet<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">(</span>dataSet<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">val</span> enriched <span class="token operator">=</span> <span class="token keyword">this</span><br>    <span class="token keyword">def</span> apply<span class="token punctuation">[</span>K<span class="token punctuation">]</span><span class="token punctuation">(</span>column<span class="token operator">:</span> Witness<span class="token punctuation">.</span>Lt<span class="token punctuation">[</span>Symbol<span class="token punctuation">]</span><span class="token punctuation">)</span><br>        <span class="token punctuation">(</span><span class="token keyword">implicit</span> exists<span class="token operator">:</span> PropertyExists<span class="token punctuation">[</span>A<span class="token punctuation">,</span> column<span class="token punctuation">.</span>T<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Column <span class="token operator">=</span><br>      <span class="token keyword">new</span> Column<span class="token punctuation">(</span>column<span class="token punctuation">.</span>value<span class="token punctuation">.</span>name<span class="token punctuation">)</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>We define a RichDataset abstraction which extends spark Dataset to provide the functionality of type checking.</p>
<p>We add an apply method which takes a Symbol and implicitly tries to get a PropertyExists instance for the column type column.T (Aux pattern at play here too!). Like always this will compile only if the column exists in A.</p>
<p>If we take our above case class Person, the following behaviour should be observed:</p>
<pre class="language-scala"><code class="language-scala">personDs <span class="token operator">=</span> Seq<span class="token punctuation">(</span>persons<span class="token punctuation">)</span><span class="token punctuation">.</span>toDS<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>enriched<br><br><span class="token keyword">val</span> ageColumn<span class="token operator">:</span> Column <span class="token operator">=</span> personDs<span class="token punctuation">(</span><span class="token symbol">'age</span><span class="token punctuation">)</span> <br><span class="token comment">//compiles</span><br><br><span class="token keyword">val</span> nameColumn<span class="token operator">:</span> Column <span class="token operator">=</span> personDs<span class="token punctuation">(</span><span class="token symbol">'namesss</span><span class="token punctuation">)</span><br><span class="token comment">//Error:(36, 56) Symbol with shapeless.tag.Tagged[String("namesss")] not found in Person</span></code></pre>
<p>and that is our first milestone!</p>
<blockquote>
<p><em>PS: we need to expose enriched as the compile will pick apply method of Dataset and not that of RichDataset.</em></p>
</blockquote>
<hr>
<h4 id="step-3%3A-let%E2%80%99s-join">Step 3: Let’s Join <a class="direct-link" href="#step-3%3A-let%E2%80%99s-join">#</a></h4>
<p>Now that we have established the usage of PropertyExists lets try to formulate a DSL we would want to use for carrying out our joins</p>
<pre class="language-scala"><code class="language-scala"><span class="token comment">//for left join//natural join single key reference</span><br>datasetA<span class="token punctuation">.</span>leftJoin<span class="token punctuation">(</span>datasetB<span class="token punctuation">)</span><span class="token punctuation">.</span>withKey<span class="token punctuation">(</span><span class="token symbol">'key</span><span class="token punctuation">)</span><br><br><span class="token comment">//natural join multiple keys</span><br>datasetA<span class="token punctuation">.</span>leftJoin<span class="token punctuation">(</span>datasetB<span class="token punctuation">)</span><span class="token punctuation">.</span>on<span class="token punctuation">(</span><span class="token string">'key1, '</span>key2<span class="token punctuation">)</span><br><br><span class="token comment">//for joins not natural.</span><br>datasetA<span class="token punctuation">.</span>leftJoin<span class="token punctuation">(</span>datasetB<span class="token punctuation">)</span> where <span class="token punctuation">{</span> <br>    datasetA<span class="token punctuation">(</span><span class="token string">'keyA) === datasetB('</span>keyB<span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre>
<p>seems pretty ok. Let’s dive in!</p>
<pre class="language-scala"><code class="language-scala"><span class="token keyword">class</span> JoinDataSet<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">,</span> joinType<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><br><span class="token keyword">object</span> JoinDataSet <span class="token punctuation">{</span><br>  <span class="token keyword">def</span> apply<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">,</span> joinType<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">new</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> joinType<span class="token punctuation">)</span><br>  <span class="token keyword">def</span> leftJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"leftOuter"</span><span class="token punctuation">)</span><br>  <span class="token keyword">def</span> rightJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>               <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"rightOuter"</span><span class="token punctuation">)</span><br>  <span class="token keyword">def</span> fullOuterJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>           <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"fullOuter"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre>
<p>We introduce a JoinDataSet which provides the syntactical sugar to facilitate the actual join operations. JoinDataSet will also provide us with the final methods of actual join as decided in DSL: <em>withKey</em>, <em>on</em> and <em>where</em>.</p>
<h5 id=".withkey">.withKey <a class="direct-link" href="#.withkey">#</a></h5>
<pre class="language-scala"><code class="language-scala"><span class="token keyword">class</span> JoinDataSet<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">,</span> joinType<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <br>  <span class="token keyword">def</span> withKey<span class="token punctuation">[</span>K<span class="token punctuation">]</span><span class="token punctuation">(</span>column<span class="token operator">:</span> Witness<span class="token punctuation">.</span>Lt<span class="token punctuation">[</span>Symbol<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">implicit</span><br>                                             lhsExists<span class="token operator">:</span> PropertyExists<span class="token punctuation">[</span>L<span class="token punctuation">,</span> column<span class="token punctuation">.</span>T<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">,</span><br>                                             rhsExists<span class="token operator">:</span> PropertyExists<span class="token punctuation">[</span>R<span class="token punctuation">,</span> column<span class="token punctuation">.</span>T<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> DataFrame <span class="token operator">=</span><br>    doJoin<span class="token punctuation">(</span>Seq<span class="token punctuation">(</span>column<span class="token punctuation">.</span>value<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><br><br>  <span class="token keyword">private</span> <span class="token keyword">def</span> doJoin<span class="token punctuation">(</span>columns<span class="token operator">:</span> Seq<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> lhs<span class="token punctuation">.</span>join<span class="token punctuation">(</span>rhs<span class="token punctuation">,</span> columns<span class="token punctuation">,</span> joinType<span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">object</span> JoinDataSet <span class="token punctuation">{</span><br>  <span class="token keyword">def</span> apply<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">,</span> joinType<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">new</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> joinType<span class="token punctuation">)</span><br>  <span class="token keyword">def</span> leftJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"leftOuter"</span><span class="token punctuation">)</span><br>  <span class="token keyword">def</span> rightJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>               <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"rightOuter"</span><span class="token punctuation">)</span><br>  <span class="token keyword">def</span> fullOuterJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>           <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"fullOuter"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre>
<p>As we can see, withKey is identical to what we achieved in our step 2 with a couple of notable differences.</p>
<blockquote>
<p><em>for a Symbol column, we check if PropertyExists for both Dataset[L] and Dataset[R] and also for both datasets the type is K.</em></p>
</blockquote>
<p>This enforces that not only column name should be the same, but also their type.</p>
<h5 id=".where">.where <a class="direct-link" href="#.where">#</a></h5>
<pre class="language-scala"><code class="language-scala"><span class="token keyword">private</span><span class="token punctuation">[</span>datasets<span class="token punctuation">]</span> <span class="token keyword">class</span> JoinDataSet<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">,</span> joinType<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <br>  <span class="token keyword">def</span> where<span class="token punctuation">(</span>column<span class="token operator">:</span> <span class="token keyword">=></span> Column<span class="token punctuation">)</span><span class="token operator">:</span> DataFrame <span class="token operator">=</span> doJoin<span class="token punctuation">(</span>column<span class="token punctuation">)</span><br><br>  <span class="token keyword">private</span> <span class="token keyword">def</span> doJoin<span class="token punctuation">(</span>columns<span class="token operator">:</span> Seq<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> lhs<span class="token punctuation">.</span>join<span class="token punctuation">(</span>rhs<span class="token punctuation">,</span> columns<span class="token punctuation">,</span> joinType<span class="token punctuation">)</span><br>  <span class="token keyword">private</span> <span class="token keyword">def</span> doJoin<span class="token punctuation">(</span>columns<span class="token operator">:</span> Column<span class="token punctuation">)</span>      <span class="token operator">=</span> lhs<span class="token punctuation">.</span>join<span class="token punctuation">(</span>rhs<span class="token punctuation">,</span> columns<span class="token punctuation">,</span> joinType<span class="token punctuation">)</span><br><br><span class="token punctuation">}</span><br><br><span class="token keyword">object</span> JoinDataSet <span class="token punctuation">{</span><br>  <span class="token keyword">def</span> apply<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">,</span> joinType<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">new</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> joinType<span class="token punctuation">)</span><br>  <span class="token keyword">def</span> leftJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"leftOuter"</span><span class="token punctuation">)</span><br>  <span class="token keyword">def</span> rightJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>               <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"rightOuter"</span><span class="token punctuation">)</span><br>  <span class="token keyword">def</span> fullOuterJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>           <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"fullOuter"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre>
<p><em>.where</em> is even simpler. It takes a nullary function which returns a Column and leverages on the way we express conditions on Column. To express Column we use the apply method we created</p>
<h5 id=".on">.on <a class="direct-link" href="#.on">#</a></h5>
<pre class="language-scala"><code class="language-scala"><span class="token keyword">class</span> JoinDataSet<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">,</span> joinType<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">object</span> on <span class="token keyword">extends</span> SingletonProductArgs <span class="token punctuation">{</span><br>    <span class="token keyword">def</span> applyProduct<span class="token punctuation">[</span>V <span class="token operator">&lt;</span><span class="token operator">:</span> HList<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">(</span>columns<span class="token operator">:</span> V<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">implicit</span><br>                                                i0<span class="token operator">:</span> ToTraversable<span class="token punctuation">.</span>Aux<span class="token punctuation">[</span>V<span class="token punctuation">,</span> List<span class="token punctuation">,</span> Symbol<span class="token punctuation">]</span><span class="token punctuation">,</span><br>                                                lhsExists<span class="token operator">:</span> PropertiesExists<span class="token punctuation">[</span>L<span class="token punctuation">,</span> V<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">,</span><br>                                                rhsExists<span class="token operator">:</span> PropertiesExists<span class="token punctuation">[</span>R<span class="token punctuation">,</span> V<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> DataFrame <span class="token operator">=</span><br>      doJoin<span class="token punctuation">(</span>columns<span class="token punctuation">.</span>toList<span class="token punctuation">[</span>Symbol<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>_<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><br><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">private</span> <span class="token keyword">def</span> doJoin<span class="token punctuation">(</span>columns<span class="token operator">:</span> Seq<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> lhs<span class="token punctuation">.</span>join<span class="token punctuation">(</span>rhs<span class="token punctuation">,</span> columns<span class="token punctuation">,</span> joinType<span class="token punctuation">)</span><br>  <span class="token keyword">private</span> <span class="token keyword">def</span> doJoin<span class="token punctuation">(</span>columns<span class="token operator">:</span> Column<span class="token punctuation">)</span>      <span class="token operator">=</span> lhs<span class="token punctuation">.</span>join<span class="token punctuation">(</span>rhs<span class="token punctuation">,</span> columns<span class="token punctuation">,</span> joinType<span class="token punctuation">)</span><br><br><span class="token punctuation">}</span><br><br><span class="token keyword">object</span> JoinDataSet <span class="token punctuation">{</span><br>  <span class="token keyword">def</span> apply<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">,</span> joinType<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">new</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> joinType<span class="token punctuation">)</span><br>  <span class="token keyword">def</span> leftJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"leftOuter"</span><span class="token punctuation">)</span><br>  <span class="token keyword">def</span> rightJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>               <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"rightOuter"</span><span class="token punctuation">)</span><br>  <span class="token keyword">def</span> fullOuterJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>           <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"fullOuter"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre>
<p>As one can observe <em>.on</em> is not a function at all! If we think on this and our definition of on method in the DSL, what we need to work on is the varargs of Symbol and for each such symbol have a PropertyExists created. Unfortunately, there is no way to convert a varargs to HList as varargs are Seq and Seq is not Product (case class type). For this Shapeless has provided a sugar abstraction SingletonProductArgs which uses dynamic programming to create an HList. the applyProduct is really an apply method on “on” object and allows us to achieve our syntax.</p>
<p>Here’s how the above code pans out:</p>
<blockquote>
<p>Given I have <strong>varargs</strong> to dynamically apply to a method named <strong>“apply”</strong> which gives out an <strong>HList V</strong>, and I can generate an implicit instance which gives <strong>List of Symbols</strong> out of it, and also for both the <strong>Datasets</strong>, <strong>PropertiesExists</strong> of <strong>type K</strong> in the <strong>HList V</strong>: do the Join.</p>
</blockquote>
<p>Heres the complete code:</p>
<pre class="language-scala"><code class="language-scala"><span class="token keyword">class</span> JoinDataSet<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">,</span> joinType<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">object</span> on <span class="token keyword">extends</span> SingletonProductArgs <span class="token punctuation">{</span><br>    <span class="token keyword">def</span> applyProduct<span class="token punctuation">[</span>V <span class="token operator">&lt;</span><span class="token operator">:</span> HList<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">(</span>columns<span class="token operator">:</span> V<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">implicit</span><br>                                                i0<span class="token operator">:</span> ToTraversable<span class="token punctuation">.</span>Aux<span class="token punctuation">[</span>V<span class="token punctuation">,</span> List<span class="token punctuation">,</span> Symbol<span class="token punctuation">]</span><span class="token punctuation">,</span><br>                                                lhsExists<span class="token operator">:</span> PropertiesExists<span class="token punctuation">[</span>L<span class="token punctuation">,</span> V<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">,</span><br>                                                rhsExists<span class="token operator">:</span> PropertiesExists<span class="token punctuation">[</span>R<span class="token punctuation">,</span> V<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> DataFrame <span class="token operator">=</span><br>      doJoin<span class="token punctuation">(</span>columns<span class="token punctuation">.</span>toList<span class="token punctuation">[</span>Symbol<span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>_<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><br><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">def</span> withKey<span class="token punctuation">[</span>K<span class="token punctuation">]</span><span class="token punctuation">(</span>column<span class="token operator">:</span> Witness<span class="token punctuation">.</span>Lt<span class="token punctuation">[</span>Symbol<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">implicit</span><br>                                             lhsExists<span class="token operator">:</span> PropertyExists<span class="token punctuation">[</span>L<span class="token punctuation">,</span> column<span class="token punctuation">.</span>T<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">,</span><br>                                             rhsExists<span class="token operator">:</span> PropertyExists<span class="token punctuation">[</span>R<span class="token punctuation">,</span> column<span class="token punctuation">.</span>T<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> DataFrame <span class="token operator">=</span><br>    doJoin<span class="token punctuation">(</span>Seq<span class="token punctuation">(</span>column<span class="token punctuation">.</span>value<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><br><br>  <span class="token keyword">def</span> where<span class="token punctuation">(</span>column<span class="token operator">:</span> <span class="token keyword">=></span> Column<span class="token punctuation">)</span><span class="token operator">:</span> DataFrame <span class="token operator">=</span> doJoin<span class="token punctuation">(</span>column<span class="token punctuation">)</span><br><br>  <span class="token keyword">private</span> <span class="token keyword">def</span> doJoin<span class="token punctuation">(</span>columns<span class="token operator">:</span> Seq<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> lhs<span class="token punctuation">.</span>join<span class="token punctuation">(</span>rhs<span class="token punctuation">,</span> columns<span class="token punctuation">,</span> joinType<span class="token punctuation">)</span><br>  <span class="token keyword">private</span> <span class="token keyword">def</span> doJoin<span class="token punctuation">(</span>columns<span class="token operator">:</span> Column<span class="token punctuation">)</span>      <span class="token operator">=</span> lhs<span class="token punctuation">.</span>join<span class="token punctuation">(</span>rhs<span class="token punctuation">,</span> columns<span class="token punctuation">,</span> joinType<span class="token punctuation">)</span><br><br><span class="token punctuation">}</span><br><br><span class="token keyword">object</span> JoinDataSet <span class="token punctuation">{</span><br>  <span class="token keyword">def</span> apply<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">,</span> joinType<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">new</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> joinType<span class="token punctuation">)</span><br>  <span class="token keyword">def</span> leftJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"leftOuter"</span><span class="token punctuation">)</span><br>  <span class="token keyword">def</span> rightJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>               <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"rightOuter"</span><span class="token punctuation">)</span><br>  <span class="token keyword">def</span> fullOuterJoin<span class="token punctuation">[</span>L<span class="token punctuation">,</span> R<span class="token punctuation">]</span><span class="token punctuation">(</span>lhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>           <span class="token operator">=</span> JoinDataSet<span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">,</span> <span class="token string">"fullOuter"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre>
<h4 id="propertiesexists%3F">PropertiesExists? <a class="direct-link" href="#propertiesexists%3F">#</a></h4>
<p>For matching multiple properties, we create another trait like PropertyExists. While PropertyExists worked with single property PName, the PropertiesExists needs to work with HList. So we get our trait as:</p>
<pre class="language-scala"><code class="language-scala"><span class="token keyword">trait</span> PropertiesExists<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PName <span class="token operator">&lt;</span><span class="token operator">:</span> HList<span class="token punctuation">,</span> PType<span class="token punctuation">]</span></code></pre>
<p>Now, like a List, HList also has 3 basic building blocks: Head, Tail and Nil (in this case HNil) where:</p>
<pre class="language-scala"><code class="language-scala">HList <span class="token operator">=</span> Head <span class="token operator">::</span> Tail <span class="token operator">::</span> HNil</code></pre>
<p>So all we need to do now is define implicitProviders for HNil, Tail and Head. Since the head is essentially a single Property, PropertyExists fits just fine! for the tail, we recursively try to create an implicit provider as we do for any List.</p>
<pre class="language-scala"><code class="language-scala"><span class="token annotation punctuation">@implicitNotFound</span><span class="token punctuation">(</span>msg <span class="token operator">=</span> <span class="token string">"${PName} not found in ${T}"</span><span class="token punctuation">)</span><br><span class="token keyword">trait</span> PropertiesExists<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PName <span class="token operator">&lt;</span><span class="token operator">:</span> HList<span class="token punctuation">,</span> PType<span class="token punctuation">]</span><br><span class="token keyword">object</span> PropertiesExists <span class="token punctuation">{</span><br>  <span class="token keyword">implicit</span> <span class="token keyword">def</span> forHNil<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PName<span class="token punctuation">,</span> PType<span class="token punctuation">]</span><span class="token punctuation">(</span><br>      <span class="token keyword">implicit</span> head<span class="token operator">:</span> PropertyExists<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PName<span class="token punctuation">,</span> PType<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> PropertiesExists<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PName <span class="token operator">::</span> HNil<span class="token punctuation">,</span> PType<span class="token punctuation">]</span> <span class="token operator">=</span><br>    <span class="token keyword">new</span> PropertiesExists<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PName <span class="token operator">::</span> HNil<span class="token punctuation">,</span> PType<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br><br>  <span class="token keyword">implicit</span> <span class="token keyword">def</span> forHList<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PNameHead<span class="token punctuation">,</span> PNameTail <span class="token operator">&lt;</span><span class="token operator">:</span> HList<span class="token punctuation">,</span> PTypeForHead<span class="token punctuation">,</span> PTypeForTail<span class="token punctuation">]</span><span class="token punctuation">(</span><br>      <span class="token keyword">implicit</span> headExists<span class="token operator">:</span> PropertyExists<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PNameHead<span class="token punctuation">,</span> PTypeForHead<span class="token punctuation">]</span><span class="token punctuation">,</span><br>      tailExists<span class="token operator">:</span> PropertiesExists<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PNameTail<span class="token punctuation">,</span> PTypeForTail<span class="token punctuation">]</span><span class="token punctuation">)</span><br>    <span class="token operator">:</span> PropertiesExists<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PNameHead <span class="token operator">::</span> PNameTail<span class="token punctuation">,</span> PTypeForTail<span class="token punctuation">]</span> <span class="token operator">=</span><br>    <span class="token keyword">new</span> PropertiesExists<span class="token punctuation">[</span>T<span class="token punctuation">,</span> PNameHead <span class="token operator">::</span> PNameTail<span class="token punctuation">,</span> PTypeForTail<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>we can complete our RichDataSet as below:</p>
<pre class="language-scala"><code class="language-scala"><span class="token keyword">object</span> syntax <span class="token punctuation">{</span><br><br>  <span class="token keyword">implicit</span> <span class="token keyword">class</span> RichDataSet<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">(</span>dataSet<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br><br>    <span class="token keyword">val</span> enriched<span class="token operator">:</span> RichDataSet<span class="token punctuation">[</span>A<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><br><br>    <span class="token keyword">def</span> apply<span class="token punctuation">[</span>K<span class="token punctuation">]</span><span class="token punctuation">(</span>column<span class="token operator">:</span> Witness<span class="token punctuation">.</span>Lt<span class="token punctuation">[</span>Symbol<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">implicit</span> lhsExists<span class="token operator">:</span> PropertyExists<span class="token punctuation">[</span>A<span class="token punctuation">,</span> column<span class="token punctuation">.</span>T<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Column <span class="token operator">=</span><br>      <span class="token keyword">new</span> Column<span class="token punctuation">(</span>column<span class="token punctuation">.</span>value<span class="token punctuation">.</span>name<span class="token punctuation">)</span><br><br>    <span class="token keyword">def</span> leftJoin<span class="token punctuation">[</span>B<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">(</span>withDataSet<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> JoinDataSet<span class="token punctuation">[</span>A<span class="token punctuation">,</span> B<span class="token punctuation">]</span>      <span class="token operator">=</span> JoinDataSet<span class="token punctuation">.</span>leftJoin<span class="token punctuation">(</span>dataSet<span class="token punctuation">,</span> withDataSet<span class="token punctuation">)</span><br>    <span class="token keyword">def</span> rightJoin<span class="token punctuation">[</span>B<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">(</span>withDataSet<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> JoinDataSet<span class="token punctuation">[</span>A<span class="token punctuation">,</span> B<span class="token punctuation">]</span>     <span class="token operator">=</span> JoinDataSet<span class="token punctuation">.</span>rightJoin<span class="token punctuation">(</span>dataSet<span class="token punctuation">,</span> withDataSet<span class="token punctuation">)</span><br>    <span class="token keyword">def</span> fullOuterJoin<span class="token punctuation">[</span>B<span class="token punctuation">,</span> K<span class="token punctuation">]</span><span class="token punctuation">(</span>withDataSet<span class="token operator">:</span> Dataset<span class="token punctuation">[</span>B<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> JoinDataSet<span class="token punctuation">[</span>A<span class="token punctuation">,</span> B<span class="token punctuation">]</span> <span class="token operator">=</span> JoinDataSet<span class="token punctuation">.</span>fullOuterJoin<span class="token punctuation">(</span>dataSet<span class="token punctuation">,</span> withDataSet<span class="token punctuation">)</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>And That’s it!</p>
<p>Pursuing type safety goes a long way in optimizing development flow, catching early issues (even before execution!) and most importantly helps writing meaningful unit tests. Apart from the type safety, I also wanted to share how Shapeless (and really generic type-level programming) can aid in writing succinct, compile-time and type-safe code and I hope I was able to do some justice to how awesome Shapeless and Frameless (for Spark Dataset) are!</p>

  </p>
  <hr><div class="publications">
    <p>This story was also published in:</p>
      <ul>
        
        <li class="p-0"><a target="_blank" href="https://codeburst.io/type-safety-and-spark-datasets-in-scala-20fa582024fc" >codeburst.io</a></li>
        
        <li class="p-0"><a target="_blank" href="https://www.signifytechnology.com/blog/2019/03/type-safety-and-spark-datasets-in-scala-by-manish-katoch" >Signify Technology</a></li>
        
      </ul>
  </div><ul class="post-nav">
      <li class="next">
        <a href="/tech/instanitable-implicits-in-scala/">Instantiable Implicits in Scala</a>
        <i class="fas fa-chevron-right tinted"></i>
      </li>
    
      <li class="previous">
        <i class="fas fa-chevron-left tinted"></i>
        <a href="/tech/headless-visual-testing-for-web-applications/">Headless Visual Testing For Web Applications</a>
      </li>
    
  </ul>
</section>
       </div>
      </div>
  </section>
    <section class="container-fluid p-0">
      
    </section>
    
    <section class="container-fluid dark-bg align-items-center mk-footer">
        <div class="row d-flex align-items-center p-0 mx-auto">
            <div class="col-lg-3 padded-col">
                <img class="hero d-block mx-auto" src="/images/about_me.jpg" />
            </div>
            <div class="col-lg-6 padded-col">
                <section class="bio">
                    I'm <b>Manish Katoch</b>.<br/><br/>
          I am a polyglot software developer who loves and strives to write simple, clean and testable code.<br/><br/>
          As a developer, I am partial towards Scala,
          Kotlin and everything functional. I also enjoy developing mobile applications and frameworks.<br/>
          As tech lead, I have collaborated with some of the key players in the Travel, BFSI and Consumer Electronics domain to build teams that create mission-critical, consumer enriching products/platforms.
          <br/><br/>
          previously worked with NVIDIA and ThoughtWorks, I currently work with a startup with a mission to make Industry 4.0 better.
        
                </section>
            </div>
            <div class="col-lg-1 padded-col"></div>
            <div class="col-lg-2 padded-col">
                
    
        <span>I'm reachable!</span><br/><br/>
        <ul class="list-unstyled p-10">
            
    
      
        <li><a target="_blank" href="mailTo:manish.katoch@gmail.com">
      
        <span><i class="fas fa-envelope-square"></i> Email</span>
    
      </a></li>
    
    
      
        <li><a target="_blank" href="https://www.linkedin.com/in/manishkkatoch/">
      
        <span><i class="fab fa-linkedin"></i> LinkedIn</span>
    
      </a></li>
    
    
      
        <li><a target="_blank" href="https://twitter.com/m_the_katoch">
      
        <span><i class="fab fa-twitter-square"></i> Twitter</span>
    
      </a></li>
    
    
      
        <li><a target="_blank" href="https://medium.com/@manish.katoch">
      
        <span><i class="fab fa-medium"></i> Medium</span>
    
      </a></li>
    
    
    
        </ul>
        <br/>
        <span>currently in:<span><br/>
        <span>Berlin, Germany</span>
    
    
            </div>
        </div>
        <div class="row d-flex align-items-center p-40 mx-auto copy">
            <p>&copy; Manish Katoch 2020</p>
        </div>
    </section>
  

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV" crossorigin="anonymous"></script>
  </body>
</html>